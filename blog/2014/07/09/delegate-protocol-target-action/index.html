
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>委托、协议、目标-动作 - Roc's Blog</title>
	<meta name="author" content="Roc">

	
	<meta name="description" content="委托、协议、目标-动作 1.委托（Delegation） 委托是一个常用、简单、灵活，但又不好解释的模式，下面我们从以下几个方面来看看什么是委托？ 面向对象中，委托是指给一个对象提供机会对另一个对象中的变化做出反应或者影响另一个对象的行为。即有两个对象参与处理同一个请求， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Roc's Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://yuxiaopeng.github.com/blog/2014/07/09/delegate-protocol-target-action/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!-- <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script> -->
	<!--[if lt IE 9]><script src="/javascripts/html5.js"></script><![endif]-->
	<!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>-->
	<script src="/javascripts/jquery.min.js"></script>
	<!--<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>-->
	<link href='/stylesheets/font.css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" -->
<!-- link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" -->
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		//document.write("<img src='http://www.gravatar.com/avatar/" + MD5("uxiaopeng@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">Roc's Blog</a></h1>
<p class="subtitle">这是最好的时代，也是最坏的时代；这是智慧的年代，也是愚昧的年代；这是信仰的时期，也是怀疑的时期；这是光明的季节，也是黑暗的季节；这是希望的春天，也是失望的冬天；大伙儿面前应有尽有，大伙儿面前一无所有；大伙儿正在直奔天堂；大伙儿正在直落地狱。——《双城记》</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/rooc" title="Weibo">Weibo</a>
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav></header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">委托、协议、目标-动作</h1>
	<div class="entry-content" itemprop="articleBody"><h3>1.委托（Delegation）</h3>

<p>委托是一个常用、简单、灵活，但又不好解释的模式，下面我们从以下几个方面来看看什么是委托？</p>

<ul>
<li><p>面向对象中，委托是指给一个对象提供机会对另一个对象中的变化做出反应或者影响另一个对象的行为。即有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。其基本思想是：两个对象协同解决问题，一个对象非常普通，并且打算在广泛的情形中重用。它存储指向另一个对象（即它的委托）的引用，并在关键时刻给委托发消息。消息可能只是通知委托发生了某件事情，给委托提供机会执行额外的处理，或者消息可能要求委托提供一些关键的信息以控制所发生的事情。</p></li>
<li><p>软件设计模式中，委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，实现对对象的行为进行定制或无子类​​覆盖。</p></li>
<li><p>编程语言特性中，委托是一种面向对象的<strong>回调</strong>（callbacks）机制。传统意义上的回调是指在某个特定事件发生前就设置好的函数。当相应的事件发生时，程序就会调用该函数。某些对象需要为多个事件设置回调，Objective-C没有内建的机制能让两个或多个回调函数协同工作并分享信息。委托解决了这个问题：单个委托对象可以接收针对某个特定对象的全部事件消息。委托对象可以根据需要，保存、修改、使用和转发相关的信息。以 <code>CLLocationManager</code> 对象为例，当该对象发现新的位置，或者发生错误时都会使用委托方法或称回调方法进行事件处理。代码见<code>协议</code>部分列出的方法。</p></li>
<li><p>实际应用中，委托类似监听器机制。譬如，要实现点击一个按钮之后做出响应，这里有一个视图类（View）和一个控制器类（Controller）。无论使用什么语言和开发工具，视图类知道用户什么时候对按钮做了操作，以及做了什么操作（单击、双击、长按），但是不知道点击事件发生后要做什么（即如何响应）；控制类知道点击按钮后做什么，而不知道用户何时对按钮做了操作、做了什么操作。那么，可以将控制类委托给视图类，当点击的时候视图类调用控制类实现的相应按钮操作的委托方法。这样就实现了视图与控制器的通信及解耦，实现事件响应，并且使视图与控制器各司其职、互不影响，如果在此基础上加入业务逻辑或数据即模型层（Model），这样就使用委托实现了MVC架构的三层架构。当然委托的应用不止于此，实际软件设计中，特别是Cocoa中很多类都使用了委托，例如：很多类都有delegate属性及相应的协议方法。</p></li>
</ul>


<p>委托模式的实现思路：</p>

<ol>
<li>在对象主体内持有一个委托对象的弱引用；</li>
<li>在对象主体在协议中定义委托方法，委托对象可以选择实现其中某些委托方法或全部方法；</li>
<li>连接对象主体和委托，通过<code>setDelegate:</code>方法来实现；</li>
<li>触发委托方法。</li>
</ol>


<h3>2.协议（protocol）</h3>

<p>凡是支持委托的对象，其背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要根据这个协议，为其<code>“感兴趣”</code>的事件实现相应的方法。如果某个类实现了某个协议中的方法，就称这个类遵守（conform）该协议。</p>

<p>针对CLLocationManager的委托对象，相应的协议部分示例代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol CLLocationManagerDelegate &lt;NSObject&gt;
</span><span class='line'>
</span><span class='line'>@optional
</span><span class='line'>
</span><span class='line'>- (void)locationManager:(CLLocationManager *)manager
</span><span class='line'>  didUpdateToLocation:(CLLocation *)newLocation
</span><span class='line'>         fromLocation:(CLLocation *)oldLocation;
</span><span class='line'>         
</span><span class='line'>- (void)locationManager:(CLLocationManager *)manager
</span><span class='line'>       didUpdateHeading:(CLHeading *)newHeading;
</span><span class='line'>       
</span><span class='line'>- (BOOL)locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)manager;
</span><span class='line'>
</span><span class='line'>- (void)locationManager:(CLLocationManager *)manager
</span><span class='line'>       didEnterRegion:(CLRegion *)region;
</span><span class='line'>  
</span><span class='line'>- (void)locationManager:(CLLocationManager *)manager
</span><span class='line'>     didFailWithError:(NSError *)error;
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>协议不是类，只是一组方法。不能为协议创建实例，或者添加实例变量。协议自身不实现方法，需要由遵守相应协议的类来实现。用于委托的协议称为<code>委托协议</code>（delegate protocols）。</p>

<h3>3.目标-动作(Target-Action)</h3>

<p>目标-动作（target-action）是一另外一种面向对象的回调模式。其工作方式为：当某个特定的事件发生（如按下按钮）时，发生事件的一方向指定的目标对象发送一个之前设置好的动作消息。针对不同的事件（例如轻按、连按或按住不放），需要创建不同的目标-动作。使用委托时，只要设置一个委托对象，就可以向该对象发送不同的事件消息。委托对象要为其“关心”的每一个事件实现相应的方法，如下图：  <br/>
<img src='/images/2014/07/delegate_target_action.png' /></p>

<h3>4.继承与委托</h3>

<p>继承通常会使子类与超类之间具有非常紧密的耦合。过度使用继承将导致创建许多特定于应用程序并且可重用性非常差的类。具有继承关系的类将在编译时静态地在子类与超类之间建立关系。在许多情况下，需要运行时的灵活性。例如，对调整窗口大小的行为的约束可能在运行时基于用户动作或手势而改变。更重要的是，用户自定义窗口行为的逻辑可能依赖于应用程序实现的详细信息。在整个Cocoa中重点强调的MVC模式中，窗口显然是视图层的一部分，但是应用程序的详细信息可以更好地封装在模型或控制器层。通过继承来添加应用程序逻辑将会导致在单独的层架构之间出现交叉感染，即紧耦合。这样架构下的程序可能复杂化对象的行为，使程序变得扩展性极差。
而使用委托解决此问题时，只需在在调整窗口大小行为发生时将消息发送给委托，委托的协议方法负责执行处理。委托可以是控制器层的一部分，并且几乎不与其他层相耦合。委托只需实现发送给它的消息对应的合适方法即可。</p>

<p>代码编写有个这样的原则：能不用继承就不用继承，能使用委托实现的就不使用继承。两个类有明显示的层级关系时使用继承，没有明显的层级关系，仅仅是为了在一个类中使用另一个类的方法时应该使用委托。例如，《重构》一书称：现在有滥用继承的趋势，JDK 中 Stack 就是一个滥用继承的典型。java.util.Stack 继承自 java.util.Vector，其实 Stack 与 Vector 在用途上完全是风马牛不相及的两个容器。</p>

<h3>5.委托的作用、优点、使用场景</h3>

<p>采用委托模式能够起到以下两方面的作用：</p>

<ol>
<li>委托协助对象主体完成某项操作，将需要定制化的操作通过委托对象来自定义实现，达到和子类化对象主体同样的作用；</li>
<li>事件监听，委托对象监听对象主体的某些重要事件，对事件做出具体响应或广播事件交给需要作出响应的对象。</li>
</ol>


<p>采用委托模式的优点如下：</p>

<ol>
<li>通过委托实现对象之间的松耦合；</li>
<li>通过委托传递消息机制实现类似MVC架构的分层解耦；</li>
<li>通过委托协议方法提高了运行时灵活性。</li>
</ol>


<p>委托的使用场景分两类：</p>

<ol>
<li>Cocoa框架类中的委托协议方法，Cocoa中很多控件都有委托协议方法，这些方法主要负责响应控件事件或控制其他对象。对于那些更复杂的控件，如：UITableView，除了要实现委托协议外，还需要实现数据源协议。这些都是委托设计模式的具体应用。委托的方法是可选的，但数据源的方法一般是必须实现的。</li>
<li>在自定义的类中，如果两个类无明显的层级关系，仅仅是为了在一个类中使用另一个类的方法时应该使用委托。</li>
</ol>


<p>参考：  <br/>
<a href="http://developer.apple.com/library/ios/#documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html"><code>Delegation</code></a>  <br/>
<a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CommunicatingWithObjects/CommunicateWithObjects.html"><code>Communicating with Objects</code></a>  <br/>
<a href="http://en.wikipedia.org/wiki/Delegation_pattern"><code>Delegation pattern</code></a></p>
</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style addthis_16x16_style">
	
	
	
	
	
	<a class="addthis_button_compact"></a>
	<a class="addthis_counter addthis_bubble_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/300/addthis_widget.js#pubid="></script>
</div>




<section>
    <!-- <h1>评论</h1> -->
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-author-key=“1”></div>
<script type="text/javascript">
    var duoshuoQuery = {short_name:"yuxiaopeng"};
    (function() {
     var ds = document.createElement('script');
     ds.type = 'text/javascript';ds.async = true;
     ds.src = 'http://static.duoshuo.com/embed.js';
     ds.charset = 'UTF-8';
     (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
     })();
    </script>
<!-- Duoshuo Comment END -->
</div>
</section>

</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2015 - Roc -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a><br/>
<span class="credit">感谢 <a href="http://gitcafe.com/signup?invited_by=yuxiaopeng" target="_blank">GitCafe</a> 为本站提供存储空间</span>
</footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->




	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-45732020-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




		</div>
	</div>
</body>
</html>
